<?xml version="1.0" encoding="UTF-8"?>
<node name="standard_water_ps" novs="true">
	<dependency name="Diffuse" type="float3" source="MaterialDiffuse" />
	<dependency name="Opacity" type="float" source="MaterialOpacity" />

	<dependency name="Shadowed" type="float" source="Shadowed" />
	<dependency name="WorldNormal" type="float3" source="WorldNormal" />
	<dependency name="WorldBump" type="float3" source="WorldBump" />
	<dependency name="TangentBump" type="float3" source="TangentBump" />
	<dependency name="WorldPositionOffset" type="float3" source="WorldPositionOffset" />
	<dependency name="WorldAmbient" type="float3" source="vAmbient" />
	<dependency name="WorldSunPosition" type="float3" source="vSunPositionWorld" />
	<dependency name="SunColor" type="float3" source="vSunColor" />
	<dependency name="Fog" type="float" source="Fog" />
	<dependency name="FogColor" type="float3" source="vFogColor" />
	<dependency name="Fogofwar" type="float" source="Fogofwar" />
	<dependency name="SpecParams" type="float3" source="vSpec" />
	<dependency name="PointLightPositionOffset" type="float3[]" size="NUM_POINT_LIGHTS" source="vPointLightPositionOffset" />
	<dependency name="PointLightColor" type="float3[]" size="NUM_POINT_LIGHTS" source="vPointLightColor" />
	<dependency name="PointLightFalloff" type="float3[]" size="NUM_POINT_LIGHTS" source="vPointLightFalloff" />
	<dependency name="ScreenPosition" type="float4" source="ScreenPosition" />

	<dependency name="cube" type="samplerCUBE" />
	<dependency name="reflection" type="sampler2D" source="reflection" />
	<dependency name="waterdistortion" type="sampler2D" source="waterdistortion" />
	<dependency name="Color0" type="float4" source="WaterColor0" />
	<dependency name="DiffuseOpacity" type="float" source="fDiffuseOpacity" />
	<dependency name="ReflectOpacity" type="float" source="fReflectOpacity" />
	<dependency name="ShaderModel" type="*" source="ShaderModel" />
	<output name="Out" type="float4" />
	<case>
		<dependency name="ShaderModel" type="hlsl" source="ShaderModel" />
		<?hlsl
			float4 f4DiffuseColor = float4(Diffuse, Opacity);
	
		#if (TEXKILL == 1)
			clip(f4DiffuseColor.a - 91.0f / 255.0f);
		#endif

			f4DiffuseColor *= Color0;
			
		#if (LIGHTING_QUALITY == 0)
			float3 f3CamDirection = -normalize(WorldPositionOffset);
		#endif

			//
			// Lighting
			//	
			
		#if (LIGHTING != 0)

			float3 f3Diffuse = WorldAmbient;
			float3 f3Specular = float3(0.0f, 0.0f, 0.0f);
			float fSpecular = SpecParams.x;

			// Sun
			#if (LIGHTING_QUALITY == 2)

				#if (WATER_QUALITY == 3)
					f3Diffuse = (f3Diffuse + DiffLight.xyz) * Shadowed;
				#else
					f3Diffuse = (f3Diffuse + DiffLight.xyz * saturate(dot(TangentBump.xyz, float3(-3.0, -3.0, 1.0)))) * Shadowed;
					f3Specular += pow(saturate(dot(TangentBump.xyz, float3(0.0, 0.0, 1.0))), SpecParams.y) * fSpecular * Shadowed;
				#endif

			#else // 0 or 1

			float3 f3Light = WorldSunPosition;		
			float3 f3HalfAngle = normalize(f3Light + f3CamDirection);
				
				#ifdef SMOOTH_SELF_OCCLUDE
			float fSelfOcclude = saturate(dot(WorldNormal, f3Light) * 5.0f);
				#else
			float fSelfOcclude = 1.0f;
				#endif
				
			float2 f2Lit; // x = diffuse, y = specular
			f2Lit.x = saturate(dot(WorldBump, f3Light));
			f2Lit.y = pow(saturate(dot(WorldBump, f3HalfAngle)), SpecParams.y) * fSpecular;
			f2Lit *= Shadowed * fSelfOcclude;

			f3Diffuse += SunColor * f2Lit.x;
			f3Specular += SunColor * f2Lit.y;
			
				#if (NUM_POINT_LIGHTS > 0 && LIGHTING_QUALITY == 0)
			// Point Lights
			[unroll(NUM_POINT_LIGHTS)] for (int i = 0; i < NUM_POINT_LIGHTS; ++i)
			{
				float3 f3DeltaPosition = PointLightPositionOffset[i] - WorldPositionOffset;
				float fDistance = length(f3DeltaPosition);
			
				float3 f3Light = normalize(f3DeltaPosition);
				float3 f3HalfAngle = normalize(f3Light + f3CamDirection);

				float fAttenuation = 1.0f - saturate(fDistance * PointLightFalloff[i].x + PointLightFalloff[i].y);
				
				float2 f2Lit; // x = diffuse, y = specular
				f2Lit.x = saturate(dot(WorldBump, f3Light));
				f2Lit.y = pow(saturate(dot(WorldBump, f3HalfAngle)), SpecParams.y) * fSpecular;
				f2Lit *= fAttenuation;
				
				f3Diffuse += PointLightColor[i] * f2Lit.x;
				f3Specular += PointLightColor[i] * f2Lit.y;
			}
				#endif

			#endif // LIGHTING_QUALITY

		#else // LIGHTING == 0
			float3 f3Diffuse = float3(1.0f, 1.0f, 1.0f);
			float3 f3Specular = float3(0.0f, 0.0f, 0.0f);
		#endif
			
			//
			// Environment
			//
			
		#if (LIGHTING_QUALITY == 0 || LIGHTING_QUALITY == 1)
			float3 f3EnviroColor = texCUBE(cube, reflect(WorldPositionOffset, WorldBump)).rgb;
		#endif

			//
			// Reflection
			//
				
			float2 f2SceneTexcoord = ScreenPosition.xy / ScreenPosition.w;

			#if (LIGHTING != 0)
				#if (WATER_QUALITY == 0)	
					f2SceneTexcoord.xy += TangentBump.xy * 0.015f;
				#elif (LIGHTING_QUALITY != 2)
					f2SceneTexcoord.xy += TangentBump.xy * 0.03f;
				#endif
			#endif
			
			#ifdef REFLECTIONS
				float4 f4ReflectionColor = tex2D(reflection, f2SceneTexcoord);
				f4ReflectionColor *= ReflectOpacity * Color0.a;
				f4ReflectionColor.a = 1.0f - f4ReflectionColor.a;
			#endif
			
			//
			// Final
			//
			
		#if (LIGHTING_QUALITY != 2)
			float3 f3FinalColor = lerp(f4DiffuseColor.rgb * f3Diffuse, f3EnviroColor, 0.35f);
		#else
			float3 f3FinalColor = f4DiffuseColor.rgb * f3Diffuse;
		#endif

			float fAlpha = f4DiffuseColor.a * DiffuseOpacity;
			
		#ifdef REFLECTIONS
			float fFinalAlpha = 1.0f - (1.0f - fAlpha) * f4ReflectionColor.a;
		#else
			float fFinalAlpha = fAlpha;
		#endif
			
		#if (WATER_QUALITY == 0)	
			float3 f3WaterDistortionColor = tex2D(waterdistortion, f2SceneTexcoord.xy).rgb;

			#ifdef REFLECTIONS
				f3FinalColor *= fAlpha * f4ReflectionColor.a;
			#else
				f3FinalColor *= fAlpha;
			#endif
			
			f3FinalColor = lerp(f3FinalColor + f3WaterDistortionColor.rgb * Color0.a, f3FinalColor, fFinalAlpha);
			
			#ifdef REFLECTIONS
				f3FinalColor += f4ReflectionColor.rgb;
			#endif
			
			fFinalAlpha = Color0.a;
		#else
			#ifdef REFLECTIONS
				f3FinalColor = f3FinalColor * fAlpha * f4ReflectionColor.a + f4ReflectionColor.rgb;
			#else
				f3FinalColor *= fAlpha;
			#endif
		#endif

			f3FinalColor += f3Specular * Color0.a;
			
			f3FinalColor *= Fogofwar;
			
			Out.rgb = lerp(f3FinalColor, FogColor, Fog);
			Out.a = fFinalAlpha;
		?>
	</case>
	<case>
		<dependency name="ShaderModel" type="hlsl5" source="ShaderModel" />
		<?hlsl
			//Out = Sampler_texture.Sample(Sampler_sampler, Texcoord);
			
			float4 f4DiffuseColor = float4(Diffuse, Opacity);
	
		#if (TEXKILL == 1)
			clip(f4DiffuseColor.a - 91.0f / 255.0f);
		#endif

			f4DiffuseColor *= Color0;
			
		#if (LIGHTING_QUALITY == 0)
			float3 f3CamDirection = -normalize(WorldPositionOffset);
		#endif

			//
			// Lighting
			//	
			
		#if (LIGHTING != 0)

			float3 f3Diffuse = WorldAmbient;
			float3 f3Specular = float3(0.0f, 0.0f, 0.0f);
			float fSpecular = SpecParams.x;

			// Sun
			#if (LIGHTING_QUALITY == 2)

				#if (WATER_QUALITY == 3)
					f3Diffuse = (f3Diffuse + DiffLight.xyz) * Shadowed;
				#else
					f3Diffuse = (f3Diffuse + DiffLight.xyz * saturate(dot(TangentBump.xyz, float3(-3.0, -3.0, 1.0)))) * Shadowed;
					f3Specular += pow(saturate(dot(TangentBump.xyz, float3(0.0, 0.0, 1.0))), SpecParams.y) * fSpecular * Shadowed;
				#endif

			#else // 0 or 1

			float3 f3Light = WorldSunPosition;		
			float3 f3HalfAngle = normalize(f3Light + f3CamDirection);
				
				#ifdef SMOOTH_SELF_OCCLUDE
			float fSelfOcclude = saturate(dot(WorldNormal, f3Light) * 5.0f);
				#else
			float fSelfOcclude = 1.0f;
				#endif
				
			float2 f2Lit; // x = diffuse, y = specular
			f2Lit.x = saturate(dot(WorldBump, f3Light));
			f2Lit.y = pow(saturate(dot(WorldBump, f3HalfAngle)), SpecParams.y) * fSpecular;
			f2Lit *= Shadowed * fSelfOcclude;

			f3Diffuse += SunColor * f2Lit.x;
			f3Specular += SunColor * f2Lit.y;
			
				#if (NUM_POINT_LIGHTS > 0 && LIGHTING_QUALITY == 0)
			// Point Lights
			[unroll(NUM_POINT_LIGHTS)] for (int i = 0; i < NUM_POINT_LIGHTS; ++i)
			{
				float3 f3DeltaPosition = PointLightPositionOffset[i] - WorldPositionOffset;
				float fDistance = length(f3DeltaPosition);
			
				float3 f3Light = normalize(f3DeltaPosition);
				float3 f3HalfAngle = normalize(f3Light + f3CamDirection);

				float fAttenuation = 1.0f - saturate(fDistance * PointLightFalloff[i].x + PointLightFalloff[i].y);
				
				float2 f2Lit; // x = diffuse, y = specular
				f2Lit.x = saturate(dot(WorldBump, f3Light));
				f2Lit.y = pow(saturate(dot(WorldBump, f3HalfAngle)), SpecParams.y) * fSpecular;
				f2Lit *= fAttenuation;
				
				f3Diffuse += PointLightColor[i] * f2Lit.x;
				f3Specular += PointLightColor[i] * f2Lit.y;
			}
				#endif

			#endif // LIGHTING_QUALITY

		#else // LIGHTING == 0
			float3 f3Diffuse = float3(1.0f, 1.0f, 1.0f);
			float3 f3Specular = float3(0.0f, 0.0f, 0.0f);
		#endif
			
			//
			// Environment
			//
			
		#if (LIGHTING_QUALITY == 0 || LIGHTING_QUALITY == 1)
			float3 f3EnviroColor = cube_texture.Sample(cube_sampler, reflect(WorldPositionOffset, WorldBump)).rgb;
		#endif

			//
			// Reflection
			//
				
			float2 f2SceneTexcoord = ScreenPosition.xy / ScreenPosition.w;

			#if (LIGHTING != 0)
				#if (WATER_QUALITY == 0)	
					f2SceneTexcoord.xy += TangentBump.xy * 0.015f;
				#elif (LIGHTING_QUALITY != 2)
					f2SceneTexcoord.xy += TangentBump.xy * 0.03f;
				#endif
			#endif
			
			#ifdef REFLECTIONS
				float4 f4ReflectionColor = reflection_texture.Sample(reflection_sampler, f2SceneTexcoord);
				f4ReflectionColor *= ReflectOpacity * Color0.a;
				f4ReflectionColor.a = 1.0f - f4ReflectionColor.a;
			#endif
			
			//
			// Final
			//
			
		#if (LIGHTING_QUALITY != 2)
			float3 f3FinalColor = lerp(f4DiffuseColor.rgb * f3Diffuse, f3EnviroColor, 0.35f);
		#else
			float3 f3FinalColor = f4DiffuseColor.rgb * f3Diffuse;
		#endif

			float fAlpha = f4DiffuseColor.a * DiffuseOpacity;
			
		#ifdef REFLECTIONS
			float fFinalAlpha = 1.0f - (1.0f - fAlpha) * f4ReflectionColor.a;
		#else
			float fFinalAlpha = fAlpha;
		#endif
			
		#if (WATER_QUALITY == 0)	
			float3 f3WaterDistortionColor = waterdistortion_texture.Sample(waterdistortion_sampler, f2SceneTexcoord.xy).rgb;

			#ifdef REFLECTIONS
				f3FinalColor *= fAlpha * f4ReflectionColor.a;
			#else
				f3FinalColor *= fAlpha;
			#endif
			
			f3FinalColor = lerp(f3FinalColor + f3WaterDistortionColor.rgb * Color0.a, f3FinalColor, fFinalAlpha);
			
			#ifdef REFLECTIONS
				f3FinalColor += f4ReflectionColor.rgb;
			#endif
			
			fFinalAlpha = Color0.a;
		#else
			#ifdef REFLECTIONS
				f3FinalColor = f3FinalColor * fAlpha * f4ReflectionColor.a + f4ReflectionColor.rgb;
			#else
				f3FinalColor *= fAlpha;
			#endif
		#endif

			f3FinalColor += f3Specular * Color0.a;
			
			f3FinalColor *= Fogofwar;
			
			Out.rgb = lerp(f3FinalColor, FogColor, Fog);
			Out.a = fFinalAlpha;
		?>
	</case>
	<case>
		<dependency name="ShaderModel" type="glsl120" source="ShaderModel" />
		<?glsl
			vec4 f4DiffuseColor = vec4(Diffuse, Opacity);
	
		#if (TEXKILL == 1)
			if (f4DiffuseColor.a < 91.0f / 255.0f)
				discard;
		#endif

			f4DiffuseColor *= Color0;
			
		#if (LIGHTING_QUALITY == 0)
			vec3 f3CamDirection = -normalize(WorldPositionOffset);
		#endif

			//
			// Lighting
			//	
			
		#if (LIGHTING != 0)

			vec3 f3Diffuse = WorldAmbient;
			vec3 f3Specular = vec3(0.0f, 0.0f, 0.0f);
			float fSpecular = SpecParams.x;

			// Sun
			#if (LIGHTING_QUALITY == 2)

				#if (WATER_QUALITY == 3)
					f3Diffuse = (f3Diffuse + DiffLight.xyz) * Shadowed;
				#else
					f3Diffuse = (f3Diffuse + DiffLight.xyz * clamp(dot(TangentBump.xyz, vec3(-3.0, -3.0, 1.0))), 0.0f, 1.0f) * Shadowed;
					f3Specular += pow(clamp(dot(TangentBump.xyz, vec3(0.0, 0.0, 1.0)), 0.0f, 1.0f), SpecParams.y) * fSpecular * Shadowed;
				#endif

			#else // 0 or 1

			vec3 f3Light = WorldSunPosition;		
			vec3 f3HalfAngle = normalize(f3Light + f3CamDirection);
				
				#ifdef SMOOTH_SELF_OCCLUDE
			float fSelfOcclude = clamp(dot(WorldNormal, f3Light) * 5.0f, 0.0f, 1.0f);
				#else
			float fSelfOcclude = 1.0f;
				#endif
				
			vec2 f2Lit; // x = diffuse, y = specular
			f2Lit.x = clamp(dot(WorldBump, f3Light), 0.0f, 1.0f);
			f2Lit.y = pow(clamp(dot(WorldBump, f3HalfAngle), 0.0f, 1.0f), SpecParams.y) * fSpecular;
			f2Lit *= Shadowed * fSelfOcclude;

			f3Diffuse += SunColor * f2Lit.x;
			f3Specular += SunColor * f2Lit.y;
			
				#if (NUM_POINT_LIGHTS > 0 && LIGHTING_QUALITY == 0)
			// Point Lights
			for (int i = 0; i < NUM_POINT_LIGHTS; ++i)
			{
				vec3 f3DeltaPosition = PointLightPositionOffset[i] - WorldPositionOffset;
				float fDistance = length(f3DeltaPosition);
			
				vec3 f3Light = normalize(f3DeltaPosition);
				vec3 f3HalfAngle = normalize(f3Light + f3CamDirection);

				float fAttenuation = 1.0f - clamp(fDistance * PointLightFalloff[i].x + PointLightFalloff[i].y, 0.0f, 1.0f);
				
				vec2 f2Lit; // x = diffuse, y = specular
				f2Lit.x = clamp(dot(WorldBump, f3Light), 0.0f, 1.0f);
				f2Lit.y = pow(clamp(dot(WorldBump, f3HalfAngle), 0.0f, 1.0f), SpecParams.y) * fSpecular;
				f2Lit *= fAttenuation;
				
				f3Diffuse += PointLightColor[i] * f2Lit.x;
				f3Specular += PointLightColor[i] * f2Lit.y;
			}
				#endif

			#endif // LIGHTING_QUALITY

		#else // LIGHTING == 0
			vec3 f3Diffuse = vec3(1.0f, 1.0f, 1.0f);
			vec3 f3Specular = vec3(0.0f, 0.0f, 0.0f);
		#endif
			
			//
			// Environment
			//
			
		#if (LIGHTING_QUALITY == 0 || LIGHTING_QUALITY == 1)
			vec3 f3EnviroColor = textureCube(cube, reflect(WorldPositionOffset, WorldBump)).rgb;
		#endif

			//
			// Reflection
			//
				
			vec2 f2SceneTexcoord = ScreenPosition.xy / ScreenPosition.w;

			#if (LIGHTING != 0)
				#if (WATER_QUALITY == 0)	
					f2SceneTexcoord.xy += TangentBump.xy * 0.015f;
				#elif (LIGHTING_QUALITY != 2)
					f2SceneTexcoord.xy += TangentBump.xy * 0.03f;
				#endif
			#endif
			
			#ifdef REFLECTIONS
				vec4 f4ReflectionColor = texture2D(reflection, f2SceneTexcoord);
				f4ReflectionColor *= ReflectOpacity * Color0.a;
				f4ReflectionColor.a = 1.0f - f4ReflectionColor.a;
			#endif
			
			//
			// Final
			//
			
		#if (LIGHTING_QUALITY != 2)
			vec3 f3FinalColor = mix(f4DiffuseColor.rgb * f3Diffuse, f3EnviroColor, 0.35f);
		#else
			vec3 f3FinalColor = f4DiffuseColor.rgb * f3Diffuse;
		#endif

			float fAlpha = f4DiffuseColor.a * DiffuseOpacity;
			
		#ifdef REFLECTIONS
			float fFinalAlpha = 1.0f - (1.0f - fAlpha) * f4ReflectionColor.a;
		#else
			float fFinalAlpha = fAlpha;
		#endif
			
		#if (WATER_QUALITY == 0)	
			vec3 f3WaterDistortionColor = texture2D(waterdistortion, f2SceneTexcoord.xy).rgb;

			#ifdef REFLECTIONS
				f3FinalColor *= fAlpha * f4ReflectionColor.a;
			#else
				f3FinalColor *= fAlpha;
			#endif
			
			f3FinalColor = mix(f3FinalColor + f3WaterDistortionColor.rgb * Color0.a, f3FinalColor, fFinalAlpha);
			
			#ifdef REFLECTIONS
				f3FinalColor += f4ReflectionColor.rgb;
			#endif
			
			fFinalAlpha = Color0.a;
		#else
			#ifdef REFLECTIONS
				f3FinalColor = f3FinalColor * fAlpha * f4ReflectionColor.a + f4ReflectionColor.rgb;
			#else
				f3FinalColor *= fAlpha;
			#endif
		#endif

			f3FinalColor += f3Specular * Color0.a;
			
			f3FinalColor *= Fogofwar;
			
			Out.rgb = mix(f3FinalColor, FogColor, Fog);
			Out.a = fFinalAlpha;
		?>
	</case>
	<case>
		<dependency name="ShaderModel" type="glsl" source="ShaderModel" />
		<?glsl
			vec4 f4DiffuseColor = vec4(Diffuse, Opacity);
	
		#if (TEXKILL == 1)
			if (f4DiffuseColor.a < 91.0f / 255.0f)
				discard;
		#endif

			f4DiffuseColor *= Color0;
			
		#if (LIGHTING_QUALITY == 0)
			vec3 f3CamDirection = -normalize(WorldPositionOffset);
		#endif

			//
			// Lighting
			//	
			
		#if (LIGHTING != 0)

			vec3 f3Diffuse = WorldAmbient;
			vec3 f3Specular = vec3(0.0f, 0.0f, 0.0f);
			float fSpecular = SpecParams.x;

			// Sun
			#if (LIGHTING_QUALITY == 2)

				#if (WATER_QUALITY == 3)
					f3Diffuse = (f3Diffuse + DiffLight.xyz) * Shadowed;
				#else
					f3Diffuse = (f3Diffuse + DiffLight.xyz * clamp(dot(TangentBump.xyz, vec3(-3.0, -3.0, 1.0))), 0.0f, 1.0f) * Shadowed;
					f3Specular += pow(clamp(dot(TangentBump.xyz, vec3(0.0, 0.0, 1.0)), 0.0f, 1.0f), SpecParams.y) * fSpecular * Shadowed;
				#endif

			#else // 0 or 1

			vec3 f3Light = WorldSunPosition;		
			vec3 f3HalfAngle = normalize(f3Light + f3CamDirection);
				
				#ifdef SMOOTH_SELF_OCCLUDE
			float fSelfOcclude = clamp(dot(WorldNormal, f3Light) * 5.0f, 0.0f, 1.0f);
				#else
			float fSelfOcclude = 1.0f;
				#endif
				
			vec2 f2Lit; // x = diffuse, y = specular
			f2Lit.x = clamp(dot(WorldBump, f3Light), 0.0f, 1.0f);
			f2Lit.y = pow(clamp(dot(WorldBump, f3HalfAngle), 0.0f, 1.0f), SpecParams.y) * fSpecular;
			f2Lit *= Shadowed * fSelfOcclude;

			f3Diffuse += SunColor * f2Lit.x;
			f3Specular += SunColor * f2Lit.y;
			
				#if (NUM_POINT_LIGHTS > 0 && LIGHTING_QUALITY == 0)
			// Point Lights
			for (int i = 0; i < NUM_POINT_LIGHTS; ++i)
			{
				vec3 f3DeltaPosition = PointLightPositionOffset[i] - WorldPositionOffset;
				float fDistance = length(f3DeltaPosition);
			
				vec3 f3Light = normalize(f3DeltaPosition);
				vec3 f3HalfAngle = normalize(f3Light + f3CamDirection);

				float fAttenuation = 1.0f - clamp(fDistance * PointLightFalloff[i].x + PointLightFalloff[i].y, 0.0f, 1.0f);
				
				vec2 f2Lit; // x = diffuse, y = specular
				f2Lit.x = clamp(dot(WorldBump, f3Light), 0.0f, 1.0f);
				f2Lit.y = pow(clamp(dot(WorldBump, f3HalfAngle), 0.0f, 1.0f), SpecParams.y) * fSpecular;
				f2Lit *= fAttenuation;
				
				f3Diffuse += PointLightColor[i] * f2Lit.x;
				f3Specular += PointLightColor[i] * f2Lit.y;
			}
				#endif

			#endif // LIGHTING_QUALITY

		#else // LIGHTING == 0
			vec3 f3Diffuse = vec3(1.0f, 1.0f, 1.0f);
			vec3 f3Specular = vec3(0.0f, 0.0f, 0.0f);
		#endif
			
			//
			// Environment
			//
			
		#if (LIGHTING_QUALITY == 0 || LIGHTING_QUALITY == 1)
			vec3 f3EnviroColor = texture(cube, reflect(WorldPositionOffset, WorldBump)).rgb;
		#endif

			//
			// Reflection
			//
				
			vec2 f2SceneTexcoord = ScreenPosition.xy / ScreenPosition.w;

			#if (LIGHTING != 0)
				#if (WATER_QUALITY == 0)	
					f2SceneTexcoord.xy += TangentBump.xy * 0.015f;
				#elif (LIGHTING_QUALITY != 2)
					f2SceneTexcoord.xy += TangentBump.xy * 0.03f;
				#endif
			#endif
			
			#ifdef REFLECTIONS
				vec4 f4ReflectionColor = texture(reflection, f2SceneTexcoord);
				f4ReflectionColor *= ReflectOpacity * Color0.a;
				f4ReflectionColor.a = 1.0f - f4ReflectionColor.a;
			#endif
			
			//
			// Final
			//
			
		#if (LIGHTING_QUALITY != 2)
			vec3 f3FinalColor = mix(f4DiffuseColor.rgb * f3Diffuse, f3EnviroColor, 0.35f);
		#else
			vec3 f3FinalColor = f4DiffuseColor.rgb * f3Diffuse;
		#endif

			float fAlpha = f4DiffuseColor.a * DiffuseOpacity;
			
		#ifdef REFLECTIONS
			float fFinalAlpha = 1.0f - (1.0f - fAlpha) * f4ReflectionColor.a;
		#else
			float fFinalAlpha = fAlpha;
		#endif
			
		#if (WATER_QUALITY == 0)	
			vec3 f3WaterDistortionColor = texture(waterdistortion, f2SceneTexcoord.xy).rgb;

			#ifdef REFLECTIONS
				f3FinalColor *= fAlpha * f4ReflectionColor.a;
			#else
				f3FinalColor *= fAlpha;
			#endif
			
			f3FinalColor = mix(f3FinalColor + f3WaterDistortionColor.rgb * Color0.a, f3FinalColor, fFinalAlpha);
			
			#ifdef REFLECTIONS
				f3FinalColor += f4ReflectionColor.rgb;
			#endif
			
			fFinalAlpha = Color0.a;
		#else
			#ifdef REFLECTIONS
				f3FinalColor = f3FinalColor * fAlpha * f4ReflectionColor.a + f4ReflectionColor.rgb;
			#else
				f3FinalColor *= fAlpha;
			#endif
		#endif

			f3FinalColor += f3Specular * Color0.a;
			
			f3FinalColor *= Fogofwar;
			
			Out.rgb = mix(f3FinalColor, FogColor, Fog);
			Out.a = fFinalAlpha;
		?>
	</case>
</node>
