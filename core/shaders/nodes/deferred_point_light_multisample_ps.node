<?xml version="1.0" encoding="UTF-8"?>
<node name="deferred_point_light_multisample_ps" novs="true">
	<dependency name="ScreenPosition" type="float4" source="ScreenPosition" />
	<dependency name="deferred0" type="sampler2DMS" source="deferred0" />
	<dependency name="deferred1" type="sampler2DMS" source="deferred1" />
		
	<dependency name="PointLightPosition" type="float3[]" size="NUM_POINT_LIGHTS" source="vPointLightPositionView" />
	<dependency name="PointLightColor" type="float3[]" size="NUM_POINT_LIGHTS" source="vPointLightColor" />
	<dependency name="PointLightFalloff" type="float3[]" size="NUM_POINT_LIGHTS" source="vPointLightFalloff" />
	
	<dependency name="DeferredPosition" type="float3" source="DeferredPositionMultisample" />
	
	<dependency name="ShaderModel" type="*" source="ShaderModel" />
	<output name="Out" type="float4" />
	<case>
		<dependency name="ShaderModel" type="hlsl" source="ShaderModel" />
		<?hlsl
			float4 f4Deferred0 = tex2Dproj(deferred0, ScreenPosition);
			float4 f4Deferred1 = tex2Dproj(deferred1, ScreenPosition);
		
			float3 f3Normal = f4Deferred1.rgb * 2.0f - 1.0f;
			
			float3 f3Position = DeferredPosition;
			float3 f3ViewRay = normalize(f3Position);
			
			float3 f3DiffuseColor = f4Deferred0.rgb;
			float3 f3SpecularColor = float3(0.1f, 0.1f, 0.1f);
			float fSpecPower = 8.0f;
			
			float3 f3Diffuse = 0.0f;
			float3 f3Specular = 0.0f;
			
			#if (NUM_POINT_LIGHTS > 0)
			// Point Lights
			[unroll(NUM_POINT_LIGHTS)] for (int i = 0; i < NUM_POINT_LIGHTS; ++i)
			{
				float3 f3DeltaPosition = PointLightPosition[i] - f3Position;
				float fDistance = length(f3DeltaPosition);
			
				float3 f3Light = normalize(f3DeltaPosition);
				float3 f3HalfAngle = normalize(f3Light - f3ViewRay);

				float fAttenuation = 1.0f - saturate(fDistance * PointLightFalloff[i].x + PointLightFalloff[i].y);
				
				float2 f2Lit; // x = diffuse, y = specular
				f2Lit.x = saturate(dot(f3Normal, f3Light));
				f2Lit.y = pow(saturate(dot(f3Normal, f3HalfAngle)), fSpecPower);
				f2Lit *= fAttenuation;
				
				f3Diffuse += PointLightColor[i] * f2Lit.x;
				f3Specular += PointLightColor[i] * f2Lit.y;
			}
			#endif
			
			Out.rgb = f3Diffuse * f3DiffuseColor + f3Specular * f3SpecularColor;
			Out.a = 0.0f;
		?>
	</case>
	<case>
		<dependency name="ShaderModel" type="hlsl5" source="ShaderModel" />
		<dependency name="SV_SampleIndex" type="uint" source="SV_SampleIndex" />
		<?hlsl
			float2 f2ScreenPositionTexcoord = float2(ScreenPosition.xy / ScreenPosition.w);

			uint2 ui2Size0, ui2Size1;
			uint uiNumSamples;
			deferred0.GetDimensions(ui2Size0.x, ui2Size0.y, uiNumSamples);
			deferred1.GetDimensions(ui2Size1.x, ui2Size1.y, uiNumSamples);

			float4 f4Deferred0 = deferred0.Load(int2(ui2Size0 * f2ScreenPositionTexcoord), SV_SampleIndex);
			float4 f4Deferred1 = deferred1.Load(int2(ui2Size1 * f2ScreenPositionTexcoord), SV_SampleIndex);
		
			float3 f3Normal = f4Deferred1.rgb * 2.0f - 1.0f;
			
			float3 f3Position = DeferredPosition;
			float3 f3ViewRay = normalize(f3Position);
			
			float3 f3DiffuseColor = f4Deferred0.rgb;
			float3 f3SpecularColor = float3(0.1f, 0.1f, 0.1f);
			float fSpecPower = 8.0f;
			
			float3 f3Diffuse = 0.0f;
			float3 f3Specular = 0.0f;
			
			#if (NUM_POINT_LIGHTS > 0)
			// Point Lights
			[unroll(NUM_POINT_LIGHTS)] for (int i = 0; i < NUM_POINT_LIGHTS; ++i)
			{
				float3 f3DeltaPosition = PointLightPosition[i] - f3Position;
				float fDistance = length(f3DeltaPosition);
			
				float3 f3Light = normalize(f3DeltaPosition);
				float3 f3HalfAngle = normalize(f3Light - f3ViewRay);

				float fAttenuation = 1.0f - saturate(fDistance * PointLightFalloff[i].x + PointLightFalloff[i].y);
				
				float2 f2Lit; // x = diffuse, y = specular
				f2Lit.x = saturate(dot(f3Normal, f3Light));
				f2Lit.y = pow(saturate(dot(f3Normal, f3HalfAngle)), fSpecPower);
				f2Lit *= fAttenuation;
				
				f3Diffuse += PointLightColor[i] * f2Lit.x;
				f3Specular += PointLightColor[i] * f2Lit.y;
			}
			#endif
			
			Out.rgb = f3Diffuse * f3DiffuseColor + f3Specular * f3SpecularColor;
			Out.a = 0.0f;
		?>
	</case>
	<case>
		<dependency name="ShaderModel" type="glsl120" source="ShaderModel" />
		<?glsl
			#error Not available for glsl 120
		?>
	</case>
	<case>
		<dependency name="ShaderModel" type="glsl" source="ShaderModel" />
		<extension name="GL_ARB_sample_shading" />
		<?glsl
			vec2 f2ScreenPositionTexcoord = vec2(ScreenPosition.xy / ScreenPosition.w);
			
			vec4 f4Deferred0 = texelFetch(deferred0, ivec2(textureSize(deferred0) * f2ScreenPositionTexcoord), gl_SampleID);
			vec4 f4Deferred1 = texelFetch(deferred1, ivec2(textureSize(deferred1) * f2ScreenPositionTexcoord), gl_SampleID);
			
			vec3 f3Normal = f4Deferred1.rgb * 2.0f - 1.0f;
			
			vec3 f3Position = DeferredPosition;
			vec3 f3ViewRay = normalize(f3Position);
			
			vec3 f3DiffuseColor = f4Deferred0.rgb;
			vec3 f3SpecularColor = vec3(0.1f, 0.1f, 0.1f);
			float fSpecPower = 8.0f;
			
			vec3 f3Diffuse = vec3(0.0f);
			vec3 f3Specular = vec3(0.0f);
			
			#if (NUM_POINT_LIGHTS > 0)
			// Point Lights
			for (int i = 0; i < NUM_POINT_LIGHTS; ++i)
			{
				vec3 f3DeltaPosition = PointLightPosition[i] - f3Position;
				float fDistance = length(f3DeltaPosition);
			
				vec3 f3Light = normalize(f3DeltaPosition);
				vec3 f3HalfAngle = normalize(f3Light - f3ViewRay);

				float fAttenuation = 1.0f - clamp(fDistance * PointLightFalloff[i].x + PointLightFalloff[i].y, 0.0f, 1.0f);
				
				vec2 f2Lit; // x = diffuse, y = specular
				f2Lit.x = clamp(dot(f3Normal, f3Light), 0.0f, 1.0f);
				f2Lit.y = pow(clamp(dot(f3Normal, f3HalfAngle), 0.0f, 1.0f), fSpecPower);
				f2Lit *= fAttenuation;
				
				f3Diffuse += PointLightColor[i] * f2Lit.x;
				f3Specular += PointLightColor[i] * f2Lit.y;
			}
			#endif
			
			Out.rgb = f3Diffuse * f3DiffuseColor + f3Specular * f3SpecularColor;
			Out.a = 0.0f;
		?>
	</case>
</node>
